{"version":3,"sources":["../src/lib/pivot/aggregations.ts","../src/lib/pivot/transformer.ts","../src/lib/pivot/schemas.ts"],"names":["sum","count","z"],"mappings":"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","file":"chunk-3V676C77.js","sourcesContent":["import type { AggregationFn, AggregationFunctions } from './types'\nimport type { AggregationFunction } from './schemas'\n\n/**\n * Sum aggregation - add all values\n */\nexport const sum: AggregationFn<number> = (values) => {\n  if (!values || values.length === 0) return 0\n  return values.reduce((acc, val) => {\n    const num = Number(val)\n    return acc + (isNaN(num) ? 0 : num)\n  }, 0)\n}\n\n/**\n * Average aggregation - calculate mean\n */\nexport const avg: AggregationFn<number> = (values) => {\n  if (!values || values.length === 0) return 0\n  const total = sum(values)\n  return (total ?? 0) / values.length\n}\n\n/**\n * Count aggregation - count non-null values\n */\nexport const count: AggregationFn = (values) => {\n  if (!values) return 0\n  return values.filter(v => v !== null && v !== undefined).length\n}\n\n/**\n * Min aggregation - find minimum value\n */\nexport const min: AggregationFn<number> = (values) => {\n  if (!values || values.length === 0) return null\n  const numbers = values.map(Number).filter(n => !isNaN(n))\n  if (numbers.length === 0) return null\n  return Math.min(...numbers)\n}\n\n/**\n * Max aggregation - find maximum value\n */\nexport const max: AggregationFn<number> = (values) => {\n  if (!values || values.length === 0) return null\n  const numbers = values.map(Number).filter(n => !isNaN(n))\n  if (numbers.length === 0) return null\n  return Math.max(...numbers)\n}\n\n/**\n * Median aggregation - find middle value\n */\nexport const median: AggregationFn<number> = (values) => {\n  if (!values || values.length === 0) return null\n  const numbers = values.map(Number).filter(n => !isNaN(n)).sort((a, b) => a - b)\n  if (numbers.length === 0) return null\n\n  const mid = Math.floor(numbers.length / 2)\n  if (numbers.length % 2 === 0) {\n    return (numbers[mid - 1] + numbers[mid]) / 2\n  }\n  return numbers[mid]\n}\n\n/**\n * First aggregation - get first value\n */\nexport const first: AggregationFn = (values) => {\n  if (!values || values.length === 0) return null\n  return values[0]\n}\n\n/**\n * Last aggregation - get last value\n */\nexport const last: AggregationFn = (values) => {\n  if (!values || values.length === 0) return null\n  return values[values.length - 1]\n}\n\n/**\n * Map of all aggregation functions\n */\nexport const aggregationFunctions: AggregationFunctions = {\n  sum,\n  avg,\n  count,\n  min,\n  max,\n  median,\n  first,\n  last,\n}\n\n/**\n * Get aggregation function by name\n */\nexport function getAggregationFunction(name: AggregationFunction): AggregationFn {\n  const fn = aggregationFunctions[name]\n  if (!fn) {\n    throw new Error(`Unknown aggregation function: ${name}`)\n  }\n  return fn\n}\n\n/**\n * Apply aggregation to a set of values\n */\nexport function aggregate(\n  values: any[],\n  field: string,\n  aggregation: AggregationFunction\n): any {\n  const fieldValues = values.map(row => row[field])\n  const fn = getAggregationFunction(aggregation)\n  return fn(fieldValues)\n}\n\n/**\n * Format aggregation function name for display\n */\nexport function formatAggregationName(agg: AggregationFunction): string {\n  const names: Record<AggregationFunction, string> = {\n    sum: 'Sum',\n    avg: 'Average',\n    count: 'Count',\n    min: 'Minimum',\n    max: 'Maximum',\n    median: 'Median',\n    first: 'First',\n    last: 'Last',\n  }\n  return names[agg] || agg\n}\n","import type { PivotConfig, PivotResult, ValueFieldConfig } from './schemas'\nimport type { PivotRow, GroupedData, UniqueValues } from './types'\nimport { aggregate } from './aggregations'\n\n/**\n * Main pivot transformation function\n * Transforms raw data into pivoted format based on configuration\n *\n * @param rawData - Array of data objects to transform\n * @param config - Pivot configuration specifying row fields, column fields, value fields, and options\n * @returns PivotResult containing transformed data, metadata, and config\n *\n * @example\n * ```typescript\n * const rawData = [\n *   { region: 'North', product: 'A', sales: 100 },\n *   { region: 'South', product: 'A', sales: 150 },\n * ]\n *\n * const config: PivotConfig = {\n *   rowFields: ['region'],\n *   columnFields: ['product'],\n *   valueFields: [{ field: 'sales', aggregation: 'sum' }],\n *   options: { showRowTotals: true, showColumnTotals: true, showGrandTotal: true }\n * }\n *\n * const result = transformToPivot(rawData, config)\n * // result.data contains the pivoted table data\n * // result.metadata contains rowCount, columnCount, uniqueValues\n * ```\n */\nexport function transformToPivot(\n  rawData: any[],\n  config: PivotConfig\n): PivotResult {\n  // Validate input\n  if (!rawData || rawData.length === 0) {\n    return {\n      data: [],\n      metadata: {\n        rowCount: 0,\n        columnCount: 0,\n        uniqueValues: {},\n      },\n      config,\n    }\n  }\n\n  // Handle unpivoted view - return raw data when no fields configured\n  if (config.rowFields.length === 0 && config.columnFields.length === 0) {\n    return {\n      data: rawData,\n      metadata: {\n        rowCount: rawData.length,\n        columnCount: Object.keys(rawData[0] || {}).length,\n        uniqueValues: {},\n      },\n      config,\n    }\n  }\n\n  // Step 1: Group data by row fields\n  const grouped = groupByFields(rawData, config.rowFields)\n\n  // Step 2: Extract unique values for pivot columns\n  const uniqueColumnValues = extractUniqueValues(rawData, config.columnFields)\n\n  // Step 3: Generate pivoted data\n  const pivotedData = generatePivotedRows(\n    grouped,\n    uniqueColumnValues,\n    config\n  )\n\n  // Step 4: Add hierarchical structure for grouped data (when multiple row fields exist)\n  const withSubtotals = config.rowFields.length > 1\n    ? addHierarchicalSubtotals(pivotedData, rawData, config, uniqueColumnValues)\n    : pivotedData\n\n  // Step 5: Add row and column totals\n  const withTotals = config.options.showRowTotals || config.options.showColumnTotals\n    ? addTotals(withSubtotals, config, uniqueColumnValues)\n    : withSubtotals\n\n  // Step 6: Add grand total if configured\n  const finalData = config.options.showGrandTotal\n    ? addGrandTotal(withTotals, config)\n    : withTotals\n\n  return {\n    data: finalData,\n    metadata: {\n      rowCount: finalData.length,\n      columnCount: calculateColumnCount(uniqueColumnValues, config.valueFields),\n      uniqueValues: Object.fromEntries(\n        Object.entries(uniqueColumnValues).map(([k, v]) => [k, Array.from(v)])\n      ),\n    },\n    config,\n  }\n}\n\n/**\n * Generate pivot column metadata\n */\nfunction generatePivotColumnMetadata(\n  uniqueColumnValues: Record<string, Set<string>>,\n  columnFields: string[],\n  valueFields: ValueFieldConfig[]\n): Array<{ pivotValue: string; field: string }> {\n  if (columnFields.length === 0) {\n    return []\n  }\n\n  const combinations = generateColumnCombinations(uniqueColumnValues, columnFields)\n  const pivotColumns: Array<{ pivotValue: string; field: string }> = []\n\n  for (const combination of combinations) {\n    for (const valueField of valueFields) {\n      pivotColumns.push({\n        pivotValue: combination[0], // For single column field, use the value directly\n        field: valueField.field,\n      })\n    }\n  }\n\n  return pivotColumns\n}\n\n/**\n * Group data by specified fields\n */\nfunction groupByFields(data: any[], fields: string[]): Map<string, any[]> {\n  if (fields.length === 0) {\n    return new Map([['__all__', data]])\n  }\n\n  const grouped = new Map<string, any[]>()\n\n  for (const row of data) {\n    const key = fields.map(field => String(row[field] ?? '')).join('|')\n    if (!grouped.has(key)) {\n      grouped.set(key, [])\n    }\n    grouped.get(key)!.push(row)\n  }\n\n  return grouped\n}\n\n/**\n * Extract unique values for pivot columns\n */\nfunction extractUniqueValues(\n  data: any[],\n  fields: string[]\n): Record<string, Set<string>> {\n  if (fields.length === 0) {\n    return {}\n  }\n\n  const uniqueValues: Record<string, Set<string>> = {}\n\n  for (const field of fields) {\n    uniqueValues[field] = new Set()\n  }\n\n  for (const row of data) {\n    for (const field of fields) {\n      const value = String(row[field] ?? '')\n      uniqueValues[field].add(value)\n    }\n  }\n\n  return uniqueValues\n}\n\n/**\n * Generate all combinations of column values\n */\nfunction generateColumnCombinations(\n  uniqueValues: Record<string, Set<string>>,\n  fields: string[]\n): string[][] {\n  if (fields.length === 0) {\n    return [[]]\n  }\n\n  const [firstField, ...restFields] = fields\n  const firstValues = Array.from(uniqueValues[firstField] || [])\n\n  if (restFields.length === 0) {\n    return firstValues.map(v => [v])\n  }\n\n  const restCombinations = generateColumnCombinations(uniqueValues, restFields)\n  const combinations: string[][] = []\n\n  for (const value of firstValues) {\n    for (const rest of restCombinations) {\n      combinations.push([value, ...rest])\n    }\n  }\n\n  return combinations\n}\n\n/**\n * Generate pivoted rows from grouped data\n */\nfunction generatePivotedRows(\n  grouped: Map<string, any[]>,\n  uniqueColumnValues: Record<string, Set<string>>,\n  config: PivotConfig\n): PivotRow[] {\n  const rows: PivotRow[] = []\n  const combinations = generateColumnCombinations(\n    uniqueColumnValues,\n    config.columnFields\n  )\n\n  for (const [groupKey, groupRows] of grouped.entries()) {\n    const rowData: PivotRow = {\n      __id: groupKey,\n      __level: 0,\n    }\n\n    // Add row field values\n    const rowFieldValues = groupKey.split('|')\n    config.rowFields.forEach((field, index) => {\n      rowData[field] = rowFieldValues[index] || ''\n    })\n\n    // Add value fields for each column combination\n    if (config.columnFields.length === 0) {\n      // No pivot columns - just aggregate values\n      for (const valueField of config.valueFields) {\n        const fieldKey = valueField.displayName || valueField.field\n        rowData[fieldKey] = aggregate(groupRows, valueField.field, valueField.aggregation)\n      }\n    } else {\n      // With pivot columns - create indexed lookup for O(1) access\n      // Build index once instead of filtering for each combination\n      const columnIndex = new Map<string, any[]>()\n      for (const row of groupRows) {\n        const key = config.columnFields\n          .map(field => String(row[field] ?? ''))\n          .join('|')\n        if (!columnIndex.has(key)) {\n          columnIndex.set(key, [])\n        }\n        columnIndex.get(key)!.push(row)\n      }\n\n      // Now use O(1) lookups instead of O(n) filtering\n      for (const combination of combinations) {\n        const lookupKey = combination.join('|')\n        const matchingRows = columnIndex.get(lookupKey) || []\n\n        // Aggregate values for matching rows\n        for (const valueField of config.valueFields) {\n          const displayName = valueField.displayName || valueField.field\n          const columnKey = [...combination, displayName].join('__')\n          rowData[columnKey] = matchingRows.length > 0\n            ? aggregate(matchingRows, valueField.field, valueField.aggregation)\n            : undefined\n        }\n      }\n    }\n\n    rows.push(rowData)\n  }\n\n  return rows\n}\n\n/**\n * Add hierarchical subtotals for grouped data\n * Creates a true parent-child tree structure with parent rows containing subRows array\n */\nfunction addHierarchicalSubtotals(\n  data: PivotRow[],\n  rawData: any[],\n  config: PivotConfig,\n  uniqueColumnValues: Record<string, Set<string>>\n): PivotRow[] {\n  if (config.rowFields.length <= 1) {\n    return data\n  }\n\n  // Build hierarchical structure recursively\n  return buildHierarchicalRows(data, config, 0)\n}\n\n/**\n * Recursively build hierarchical row structure\n * @param rows - Flat rows to group\n * @param config - Pivot configuration\n * @param level - Current hierarchy level (0 = top level)\n * @returns Array of parent rows with subRows containing children\n */\nfunction buildHierarchicalRows(\n  rows: PivotRow[],\n  config: PivotConfig,\n  level: number\n): PivotRow[] {\n  if (level >= config.rowFields.length - 1) {\n    // Base case: we're at the last row field level, return leaf rows\n    // Update __level so child rows can display the correct field value\n    return rows.map(row => ({ ...row, __level: level }))\n  }\n\n  const currentField = config.rowFields[level]\n  const groupMap = new Map<string, PivotRow[]>()\n\n  // Group rows by current field\n  for (const row of rows) {\n    const key = String(row[currentField] ?? '')\n    if (!groupMap.has(key)) {\n      groupMap.set(key, [])\n    }\n    groupMap.get(key)!.push(row)\n  }\n\n  const parentRows: PivotRow[] = []\n\n  // Create parent row for each group\n  for (const [groupKey, groupRows] of groupMap.entries()) {\n    // Recursively build children\n    const children = buildHierarchicalRows(groupRows, config, level + 1)\n\n    // Create parent row with aggregated values\n    const parentRow: PivotRow = {\n      __id: `${currentField}_${groupKey}_level${level}`,\n      __level: level,\n      __groupKey: groupKey,\n      __expanded: config.options.expandedByDefault ?? false,\n    }\n\n    // Set current field value\n    parentRow[currentField] = groupKey\n\n    // Aggregate values from all children (recursively including all descendants)\n    aggregateParentValues(parentRow, groupRows, config)\n\n    // Attach children\n    parentRow.subRows = children\n\n    parentRows.push(parentRow)\n  }\n\n  return parentRows\n}\n\n/**\n * Aggregate values for a parent row from all its children\n * @param parentRow - Parent row to populate with aggregated values\n * @param childRows - All descendant rows (flat list including all levels)\n * @param config - Pivot configuration\n */\nfunction aggregateParentValues(\n  parentRow: PivotRow,\n  childRows: PivotRow[],\n  config: PivotConfig\n): void {\n  if (config.columnFields.length === 0) {\n    // No pivot columns - aggregate value fields directly\n    for (const valueField of config.valueFields) {\n      const displayName = valueField.displayName || valueField.field\n      const values = childRows\n        .map(row => row[displayName])\n        .filter(v => v !== null && v !== undefined)\n\n      if (valueField.aggregation === 'sum') {\n        parentRow[displayName] = values.reduce((sum, val) => sum + Number(val || 0), 0)\n      } else if (valueField.aggregation === 'count') {\n        parentRow[displayName] = values.length\n      } else if (valueField.aggregation === 'avg') {\n        const sum = values.reduce((sum, val) => sum + Number(val || 0), 0)\n        parentRow[displayName] = values.length > 0 ? sum / values.length : 0\n      } else if (valueField.aggregation === 'min') {\n        parentRow[displayName] = values.length > 0 ? Math.min(...values.map(Number)) : 0\n      } else if (valueField.aggregation === 'max') {\n        parentRow[displayName] = values.length > 0 ? Math.max(...values.map(Number)) : 0\n      } else if (valueField.aggregation === 'first') {\n        parentRow[displayName] = values[0]\n      } else if (valueField.aggregation === 'last') {\n        parentRow[displayName] = values[values.length - 1]\n      } else if (valueField.aggregation === 'median') {\n        const sorted = values.map(Number).sort((a, b) => a - b)\n        const mid = Math.floor(sorted.length / 2)\n        parentRow[displayName] = sorted.length % 2 === 0\n          ? (sorted[mid - 1] + sorted[mid]) / 2\n          : sorted[mid]\n      }\n    }\n  } else {\n    // With pivot columns - aggregate for each dynamically generated column\n    const firstRow = childRows[0]\n    for (const key of Object.keys(firstRow)) {\n      if (key.startsWith('__')) continue\n      if (config.rowFields.includes(key)) continue\n\n      const values = childRows\n        .map(row => row[key])\n        .filter(v => v !== null && v !== undefined && !isNaN(Number(v)))\n\n      if (values.length > 0) {\n        parentRow[key] = values.reduce((sum, val) => sum + Number(val), 0)\n      }\n    }\n  }\n}\n\n/**\n * Add row and column totals\n */\nfunction addTotals(\n  data: PivotRow[],\n  config: PivotConfig,\n  uniqueColumnValues: Record<string, Set<string>>\n): PivotRow[] {\n  if (!config.options.showRowTotals && !config.options.showColumnTotals) {\n    return data\n  }\n\n  const withRowTotals = config.options.showRowTotals && config.columnFields.length > 0\n    ? addRowTotals(data, config, uniqueColumnValues)\n    : data\n\n  const withColumnTotals = config.options.showColumnTotals\n    ? addColumnTotals(withRowTotals, config, uniqueColumnValues)\n    : withRowTotals\n\n  return withColumnTotals\n}\n\n/**\n * Add row total columns\n */\nfunction addRowTotals(\n  data: PivotRow[],\n  config: PivotConfig,\n  uniqueColumnValues: Record<string, Set<string>>\n): PivotRow[] {\n  if (config.columnFields.length === 0) {\n    return data\n  }\n\n  return data.map(row => {\n    const rowWithTotal = { ...row }\n    const combinations = generateColumnCombinations(\n      uniqueColumnValues,\n      config.columnFields\n    )\n\n    for (const valueField of config.valueFields) {\n      const values: any[] = []\n      const displayName = valueField.displayName || valueField.field\n\n      for (const combination of combinations) {\n        const columnKey = [...combination, displayName].join('__')\n        if (rowWithTotal[columnKey] !== null && rowWithTotal[columnKey] !== undefined) {\n          values.push(rowWithTotal[columnKey])\n        }\n      }\n\n      const aggregateFn = valueField.aggregation\n\n      if (aggregateFn === 'count' || aggregateFn === 'sum') {\n        // For count and sum, add up all the values\n        rowWithTotal['__TOTAL__'] = values.reduce((sum, val) => sum + Number(val || 0), 0)\n      } else if (aggregateFn === 'avg') {\n        const sum = values.reduce((sum, val) => sum + Number(val || 0), 0)\n        rowWithTotal['__TOTAL__'] = values.length > 0 ? sum / values.length : 0\n      } else if (aggregateFn === 'min') {\n        rowWithTotal['__TOTAL__'] = values.length > 0 ? Math.min(...values.map(Number)) : 0\n      } else if (aggregateFn === 'max') {\n        rowWithTotal['__TOTAL__'] = values.length > 0 ? Math.max(...values.map(Number)) : 0\n      } else if (aggregateFn === 'first') {\n        rowWithTotal['__TOTAL__'] = values.length > 0 ? values[0] : undefined\n      } else if (aggregateFn === 'last') {\n        rowWithTotal['__TOTAL__'] = values.length > 0 ? values[values.length - 1] : undefined\n      } else if (aggregateFn === 'median') {\n        if (values.length > 0) {\n          const sorted = [...values].map(Number).sort((a, b) => a - b)\n          const mid = Math.floor(sorted.length / 2)\n          rowWithTotal['__TOTAL__'] = sorted.length % 2 === 0\n            ? (sorted[mid - 1] + sorted[mid]) / 2\n            : sorted[mid]\n        } else {\n          rowWithTotal['__TOTAL__'] = 0\n        }\n      }\n    }\n\n    return rowWithTotal\n  })\n}\n\n/**\n * Add column total rows\n */\nfunction addColumnTotals(\n  data: PivotRow[],\n  config: PivotConfig,\n  uniqueColumnValues: Record<string, Set<string>>\n): PivotRow[] {\n  if (config.columnFields.length === 0) {\n    return data\n  }\n\n  const columnTotalRow: PivotRow = {\n    __id: '__column_total__',\n    __isColumnTotal: true,\n    __level: 0,\n  }\n\n  // Set identifier for first row field or first column field\n  if (config.rowFields.length > 0) {\n    columnTotalRow[config.rowFields[0]] = '__COLUMN_TOTAL__'\n  } else if (config.columnFields.length > 0) {\n    columnTotalRow[config.columnFields[0]] = '__COLUMN_TOTAL__'\n  }\n\n  // Calculate column totals for all value columns\n  const firstRow = data[0]\n  let grandTotal = 0\n\n  for (const key of Object.keys(firstRow)) {\n    if (key.startsWith('__')) continue\n    if (config.rowFields.includes(key)) continue\n\n    const values = data\n      .filter(row => !row.__isGrandTotal && !row.__isColumnTotal && !row.__isSubtotal)\n      .map(row => row[key])\n      .filter(val => val !== null && val !== undefined && !isNaN(Number(val)))\n\n    if (values.length > 0) {\n      const total = values.reduce((sum, val) => sum + Number(val), 0)\n      columnTotalRow[key] = total\n\n      // Add to grand total if this is a regular column (not a __TOTAL__ key)\n      if (key !== '__TOTAL__') {\n        grandTotal += total\n      }\n    }\n  }\n\n  // Add grand total column if there are pivot columns with row totals enabled\n  if (config.options.showRowTotals) {\n    columnTotalRow['__TOTAL__'] = grandTotal\n  }\n\n  return [...data, columnTotalRow]\n}\n\n/**\n * Add grand total row\n */\nfunction addGrandTotal(\n  data: PivotRow[],\n  config: PivotConfig\n): PivotRow[] {\n  if (data.length === 0) return data\n\n  const grandTotal: PivotRow = {\n    __id: '__grand_total__',\n    __isGrandTotal: true,\n    __level: 0,\n  }\n\n  // Set identifier for first row field\n  if (config.rowFields.length > 0) {\n    grandTotal[config.rowFields[0]] = '__GRAND_TOTAL__'\n  }\n\n  // Calculate totals for all value columns\n  const firstRow = data[0]\n  for (const key of Object.keys(firstRow)) {\n    if (key.startsWith('__')) continue\n    if (config.rowFields.includes(key)) continue\n\n    const values = data\n      .filter(row => !row.__isGrandTotal && !row.__isSubtotal)\n      .map(row => row[key])\n      .filter(val => val !== null && val !== undefined && !isNaN(Number(val)))\n\n    if (values.length > 0) {\n      // Use sum for now - in real implementation would check aggregation type\n      grandTotal[key] = values.reduce((sum, val) => sum + Number(val), 0)\n    }\n  }\n\n  return [...data, grandTotal]\n}\n\n/**\n * Calculate total number of columns\n */\nfunction calculateColumnCount(\n  uniqueColumnValues: Record<string, Set<string>>,\n  valueFields: ValueFieldConfig[]\n): number {\n  if (Object.keys(uniqueColumnValues).length === 0) {\n    return valueFields.length\n  }\n\n  let count = 1\n  for (const values of Object.values(uniqueColumnValues)) {\n    count *= values.size\n  }\n  return count * valueFields.length\n}\n\n/**\n * Generate column key from pivot column values and value field\n */\nexport function generateColumnKey(\n  columnValues: string[],\n  valueField: string\n): string {\n  return [...columnValues, valueField].join('__')\n}\n\n/**\n * Parse column key back into components\n */\nexport function parseColumnKey(\n  key: string,\n  columnFieldCount: number\n): { columnValues: string[]; valueField: string } {\n  const parts = key.split('__')\n  const columnValues = parts.slice(0, columnFieldCount)\n  const valueField = parts.slice(columnFieldCount).join('__')\n  return { columnValues, valueField }\n}\n","import { z } from 'zod'\n\n/**\n * Aggregation function types supported by the pivot table\n */\nexport const AggregationFunctionSchema = z.enum([\n  'sum',\n  'avg',\n  'count',\n  'min',\n  'max',\n  'median',\n  'first',\n  'last',\n])\n\nexport type AggregationFunction = z.infer<typeof AggregationFunctionSchema>\n\n/**\n * Configuration for a value field with its aggregation function\n */\nexport const ValueFieldConfigSchema = z.object({\n  field: z.string(),\n  aggregation: AggregationFunctionSchema,\n  displayName: z.string().optional(),\n})\n\nexport type ValueFieldConfig = z.infer<typeof ValueFieldConfigSchema>\n\n/**\n * Complete pivot table configuration\n */\nexport const PivotConfigSchema = z.object({\n  // Fields to group by (become row headers)\n  rowFields: z.array(z.string()).default([]),\n\n  // Fields to pivot (become column headers)\n  columnFields: z.array(z.string()).default([]),\n\n  // Fields to aggregate with their aggregation functions\n  valueFields: z.array(ValueFieldConfigSchema).min(1, 'At least one value field is required'),\n\n  // Optional filter configuration\n  filters: z.record(z.string(), z.any()).optional(),\n\n  // Configuration options\n  options: z.object({\n    showRowTotals: z.boolean().default(true),\n    showColumnTotals: z.boolean().default(true),\n    showGrandTotal: z.boolean().default(true),\n    expandedByDefault: z.boolean().default(false),\n  }).default({\n    showRowTotals: true,\n    showColumnTotals: true,\n    showGrandTotal: true,\n    expandedByDefault: false,\n  }),\n})\n\nexport type PivotConfig = z.infer<typeof PivotConfigSchema>\n\n/**\n * Metadata about the pivot result\n */\nexport const PivotMetadataSchema = z.object({\n  rowCount: z.number(),\n  columnCount: z.number(),\n  uniqueValues: z.record(z.string(), z.array(z.string())),\n  totalRows: z.number().optional(),\n})\n\nexport type PivotMetadata = z.infer<typeof PivotMetadataSchema>\n\n/**\n * Complete pivot result returned from the transformation\n */\nexport const PivotResultSchema = z.object({\n  data: z.array(z.record(z.string(), z.any())),\n  metadata: PivotMetadataSchema,\n  config: PivotConfigSchema,\n})\n\nexport type PivotResult = z.infer<typeof PivotResultSchema>\n\n/**\n * Export format options\n */\nexport const ExportFormatSchema = z.enum(['csv', 'excel', 'json'])\n\nexport type ExportFormat = z.infer<typeof ExportFormatSchema>\n\n/**\n * Export configuration\n */\nexport const ExportConfigSchema = z.object({\n  format: ExportFormatSchema,\n  includeTotals: z.boolean().default(true),\n  filename: z.string().optional(),\n})\n\nexport type ExportConfig = z.infer<typeof ExportConfigSchema>\n"]}